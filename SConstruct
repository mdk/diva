import                          re;
import                          os;
import                          SCons;

# OPTIONS ######################################################################

opts =                          Variables ('diva.conf');

opts.Add                        (BoolVariable ('GDVDEBUG', 'Enable extra Gdv debug messages', 0));
opts.Add                        (BoolVariable ('MCSDEBUG', 'Enable debugging information generated by mcs', 0));

opts.Add                        (PathVariable ('PREFIX', 'System base prefix path', '/usr'));
opts.Add                        (PathVariable ('LIBDIR', 'System library path', '$PREFIX/lib'));
opts.Add                        (PathVariable ('BINDIR', 'System executable path', '$PREFIX/bin'));
opts.Add                        (PathVariable ('SHAREDIR', 'System shared data path', '$PREFIX/share'));
opts.Add                        (PathVariable ('DESTDIR', 'System base installation path', '/'));
opts.Add                        (PathVariable ('LOCALEDIR', 'System locale installation path', '$SHAREDIR/locale'));

#opts.Add                        (PathVariable ('PREFIX', 'System base prefix path', '/usr', PathOption.PathIsDirCreate));
#opts.Add                        (PathVariable ('LIBDIR', 'System library path', '$PREFIX/lib', PathOption.PathIsDirCreate));
#opts.Add                        (PathVariable ('BINDIR', 'System executable path', '$PREFIX/bin', PathOption.PathIsDirCreate));
#opts.Add                        (PathVariable ('SHAREDIR', 'System shared data path', '$PREFIX/share', PathOption.PathIsDirCreate));
#opts.Add                        (PathVariable ('DESTDIR', 'System base installation path', '/', PathOption.PathIsDirCreate));
#opts.Add                        (PathVariable ('LOCALEDIR', 'System locale installation path', '$SHAREDIR/locale', PathOption.PathIsDirCreate));

# The above code fixes the problem with the error about non-existing paths. 
# Unfortunately, it doesn't work with the older (more popular) SCons versions, 
# so we're leaving it commented out. 
#
# If you're a package maintainer (and you can install the newer SCons) 
# you might be interested in uncommenting it (and commecnting-out the previous bits) 
# for easier package building. 
#
# See bugs 91 and 104 for more info about this problem.
# 
# Newer Scons also fixes the problem with .sconsign files being spread all over
# the place.

# VERSION ######################################################################

Version =                       '0.0.3' ;
VersionSlug =                   'TRUNK' ;

# MOTD #########################################################################

if os.system ('test -f config.log') and not GetOption ('clean'):
        print;
        os.system ('cat MOTD');
        print;
        
if GetOption ('clean'):
        if not os.system ('test -f config.log'): Execute (Delete ('config.log'));

# MCS BUILDER ##################################################################

def mcsbuilder (source, target, env, for_signature, type):
        
        sourcesList = '';
        pkgList = '';
        refList = '';
        grefList = '';
        resList = '';
       
        # Create a list with all the sources
        for src in source:
                sourcesList += ' ' + str (src);

        # All the packages
        for pkg in env ['PKG']:
                pkgList += ' ' + '-pkg:%s' % (pkg);
        
        # All the references
        for ref in env ['REF']:
                if ref.startswith ('#'):
                        refList += ' ' + '-r:%s' % (ref.strip ('#'));
                else:
                        refList += ' ' + '-r:${TARGET.dir}/%s' % (ref);
       
        # All the global references
        for gref in env ['GREF']:
                grefList += ' ' + '-r:%s' % (gref);
 
        # All the resources
        for res in env ['RESOURCE']:
                if res.startswith ('#'):
                        resList += ' ' + '-resource:%s' % (res);
                else:
                        resList += ' ' + '-resource:${TARGET.dir}/%s' % (res);

        # Return the prepared string
        cmd = 'gmcs ';
        
        if env ['MCSDEBUG'] :
            cmd += '-debug -define:DEBUG';
                
        cmd += '%s %s %s %s %s -out:%s -target:%s' % \
               (pkgList, refList, sourcesList, resList, grefList, str(target[0]), type);

        return cmd;
        
def mcslibrary_action (source, target, env, for_signature):
        return mcsbuilder (source, target, env, for_signature, 'library');
        
def mcsexe_action (source, target, env, for_signature):
        return mcsbuilder (source, target, env, for_signature, 'exe');

# MCS DEP SCANNER ##############################################################

def mcs_scanner (node, env, path):
        
        # Scan all the refs
        path = env.GetLaunchDir ();
        depList = Split ('');
        for ref in env ['REF']:
                if ref.startswith ('#'):
                        depList.append ('%s/%s' % (path, ref.strip ('#')));
                else:
                        depList.append ('%s' % ref);

        # Scan all the resources
        resList = Split ('');
        for res in env ['RESOURCE']:
                if res.startswith ('#'):
                        depList.append ('%s/%s' % res);
                else:
                        depList.append ('%s' % res);
        return depList;

# MCS EMITTER ##################################################################
        
def mcs_emitter (target, source, env):
        
        # Add the debug target
        if env ['MCSDEBUG'] :
            target.append (str (target[0]) + '.mdb');
                            
        return target, source;
        
# CUSTOM CHECK FUNC ############################################################

def CheckPkg (context, pkg, version):
        msg = 'Checking for pkg %s >= %s ... ' % (pkg, version)
        context.Message ('   %-60s ' % (msg));
        result = os.system ('pkg-config --atleast-version %s %s' % (version, pkg) );
        if result == 0:
                result = 'yes';
        else:
                result = 0;

        context.Result(result)
        return result;

# SUBST ########################################################################

def do_subst_in_file (targetfile, sourcefile, dict):
        try:
                f = open (sourcefile, 'rb')
                contents = f.read ()
                f.close ()
        except:
                raise SCons.Errors.UserError, "Can't read source file %s" % sourcefile
        for (k,v) in dict.items ():
                contents = re.sub (k, v, contents)
        try:
                f = open (targetfile, 'wb')
                f.write (contents)
                f.close ()
                os.chmod (str (targetfile), os.stat (str (sourcefile)).st_mode);
        except:
                raise SCons.Errors.UserError, "Can't write target file %s" % targetfile
        return 0

def subst_in_file (target, source, env):
        d = dict (get_dict (env))
        for (k,v) in d.items ():
                if callable (v):
                        d [k] = env.subst (v())
                elif SCons.Util.is_String (v):
                        d [k]=env.subst (v)
                else:
                        raise SCons.Errors.UserError, "SubstInFile: key %s: %s must be a string or callable" % (k, repr(v))
        for (t,s) in zip (target, source):
                return do_subst_in_file (str (t), str (s), d)
        
def subst_in_file_string (target, source, env):
        return '\n'.join (['Substituting vars from %s into %s' % (str (s), str (t))
                           for (t,s) in zip(target, source)])

def subst_emitter (target, source, env):
        d = dict (get_dict (env))
        for (k,v) in d.items ():
                if callable (v):
                        d[k] = env.subst (v())
                elif SCons.Util.is_String (v):
                        d[k]=env.subst (v)
        Depends (target, SCons.Node.Python.Value (d))
        return target, source

subst_action = SCons.Action.Action (subst_in_file, subst_in_file_string)

substVar = Builder              (action=subst_action, emitter=subst_emitter)

# MO BUILDER ###############################################################

def mobuilder_action (source, target, env, for_signature):
        cmd = 'msgfmt %s -o %s' % (source[0], target[0]);
        return cmd

moFile = Builder                (generator = mobuilder_action);

# ENV ##########################################################################

mcsScanner = Scanner            (function = mcs_scanner);

mcsDll = Builder                (generator = mcslibrary_action, target_scanner = mcsScanner,
                                 emitter = mcs_emitter);
mcsExe = Builder                (generator = mcsexe_action, target_scanner = mcsScanner,
                                 emitter = mcs_emitter);

shellEnv = Environment          (options = opts,
                                 BUILDERS = {'Subst' : substVar},
                                 ENV = os.environ);

Help                            (opts.GenerateHelpText (shellEnv));

if not shellEnv.GetOption       ('clean'):
        opts.Save                       ('diva.conf', shellEnv);

monoEnv = Environment           (options = opts,
                                 BUILDERS = {'Dll' : mcsDll, 'Exe' : mcsExe},
                                 ENV = os.environ,
                                 PKG = Split (''),
                                 REF = Split (''),
                                 GREF = Split (''),
                                 RESOURCE = Split (''));

CEnv = Environment              (options = opts, 
                                 LIBPATH = Split ('#src/Gdv/ #src/Gdv.Base/ #src/Diva.Cairo/'),
                                 CPPDEFINES = {}#{'GDV_ENABLE_MESSAGES' : '${GDVDEBUG}'}
                                );

CEnv.Append                     (CCFLAGS = Split ('-Wall'));

localeEnv = Environment         (BUILDERS = {'Locale' : moFile },
                                 options = opts, 
                                 ENV = os.environ);

# GLOBAL CHECKS ################################################################

if not CEnv.GetOption           ('clean'):
        print
        print "Dependency check:"
        print

if not CEnv.GetOption           ('clean'):
        Cconf = Configure       (CEnv, custom_tests = {'CheckPkg' : CheckPkg })
        if not Cconf.CheckPkg   ('gstreamer-0.10', '0.10.6'): Exit(1);
        if not Cconf.CheckPkg   ('gstreamer-base-0.10', '0.10.6'): Exit(1);
        if not Cconf.CheckPkg   ('gstreamer-plugins-base-0.10', '0.10.7'): Exit(1);
        if not Cconf.CheckPkg   ('gtk+-2.0', '2.8.0'): Exit(1);
        if not Cconf.CheckPkg   ('cairo', '1.0.0'): Exit(1);
        Cconf.Finish            ();

if not monoEnv.GetOption        ('clean'):
        monoConf = Configure    (monoEnv, custom_tests = {'CheckPkg' : CheckPkg })
        if not monoConf.CheckPkg('mono', '1.1'): Exit (1);
        if not monoConf.CheckPkg('gtk-sharp-2.0', '2.8.0'): Exit (1);
        if not monoConf.CheckPkg('gconf-sharp-2.0', '2.8.0'): Exit (1);
        if not monoConf.CheckPkg('gnome-sharp-2.0', '2.8.0'): Exit (1);
        monoConf.Finish         ();

# ENV PARSE ####################################################################

def print_config (msg, env):
        print
        print msg
        print
        print "   %-60s %s" % ("VERSION", Version)
        print "   %-60s %s" % ("VERSIONSLUG", VersionSlug)
        print
        print "   %-60s %s" % ("PREFIX", env.subst (env ['PREFIX']))
        print "   %-60s %s" % ("LIBDIR", env.subst (env ['LIBDIR']))
        print "   %-60s %s" % ("SHAREDIR", env.subst (env ['SHAREDIR']))
        print "   %-60s %s" % ("BINDIR", env.subst (env ['BINDIR']))
        print "   %-60s %s" % ("DESTDIR", env.subst (env ['DESTDIR']))
        print "   %-60s %s" % ("LOCALEDIR", env.subst (env ['LOCALEDIR']))
        print
        print "   %-60s %s" % ("MCSDEBUG", ("true", "false") [env.subst (env ['MCSDEBUG']) != 1])
        print "   %-60s %s" % ("GDVDEBUG", ("true", "false") [env.subst (env ['GDVDEBUG']) != 1])
        print


def get_dict (env):
        return {
                "%PREFIX%" : env ['PREFIX'],
                "%BINDIR%" : env ['BINDIR'],
                "%LIBDIR%" : env ['LIBDIR'],
                "%SHAREDIR%" : env ['SHAREDIR'],
                "%LOCALEDIR%" : env ['LOCALEDIR'],
                "%DESTDIR%" : env ['DESTDIR'],
                "%VERSION%" : Version,
                "%VERSIONSLUG%" : VersionSlug,
                }

# CONFIGS ######################################################################

CEnv.ParseConfig                 ('pkg-config --cflags --libs gstreamer-0.10');
CEnv.ParseConfig                 ('pkg-config --cflags --libs gtk+-2.0');
CEnv.ParseConfig                 ('pkg-config --cflags --libs gstreamer-base-0.10');
CEnv.ParseConfig                 ('pkg-config --cflags --libs gstreamer-plugins-base-0.10');
if not shellEnv.GetOption        ('clean'):
        print_config             ("Options:", shellEnv);

# INSTALL ######################################################################

try:
        umask = os.umask(022)
except OSError:
        pass

# BUILD ########################################################################

Export                          ('monoEnv');
Export                          ('CEnv');
Export                          ('CheckPkg');
Export                          ('shellEnv');
Export                          ('localeEnv');

SConscript                      ('src/SConscript');
SConscript                      ('test/SConscript');
SConscript                      ('bin/SConscript');
SConscript                      ('sys/SConscript');
SConscript                      ('po/SConscript');

Default                         ('src');
Default                         ('bin')
Default                         ('po');
Default                         ('sys');

if CEnv.GetOption               ('clean'): 
        Default ('.');
